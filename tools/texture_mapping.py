#!/usr/bin/env python

###############################################################################
# Copyright Kitware Inc. and Contributors
# Distributed under the Apache License, 2.0 (apache.org/licenses/LICENSE-2.0)
# See accompanying Copyright.txt and LICENSE files for details
###############################################################################


"""
Creates the texture mapped OBJ, MTL and texture PNG.
This is part of the pipeline to process an AOI from start to finish
"""

import argparse
from danesfield import gdal_utils
import dtm_to_mesh
import fnmatch
import glob
import logging
import merge_raw_obj_meshes
import os
import osr
import shutil
import subprocess
import sys
import triangulate_mesh


def texture_mapping(dsm_file, dtm_file, crops, output_dir, orig_meshes, occlusion_mesh):
    dsm = gdal_utils.gdal_open(dsm_file)
    dsmProjection = dsm.GetProjection()
    dsmSrs = osr.SpatialReference(wkt=dsmProjection)
    dsmUTMZone = dsmSrs.GetUTMZone()
    print("UTM Zone: {}".format(dsmUTMZone))

    # -------- Prepare meshes --------

    # Turn mesh into triangular faces
    tri_meshes_dir = os.path.join(output_dir, "tri")
    if not os.path.isdir(tri_meshes_dir):
        os.mkdir(tri_meshes_dir)
    # mesh offset
    offset = [0.0, 0.0, 0.0]
    gdal_utils.read_offset(orig_meshes[0], offset)
    print("Offset: {}".format(offset))
    for mesh in orig_meshes:
        cmd_args = [mesh, tri_meshes_dir]
        triangulate_mesh.main(cmd_args)

    tri_meshes = glob.glob(os.path.join(tri_meshes_dir, "*.obj"))
    # Generate the mesh of the ground
    logging.info("---- Generate ground mesh from DTM ----")
    ground_mesh = os.path.join(tri_meshes_dir, str(len(tri_meshes))+"_ground.obj")
    cmd_args = [dtm_file, ground_mesh, "--offset"] + list(map(str, offset)) + ["--downsample", "40"]
    script_call = ["dtm_to_mesh.py"] + cmd_args
    print(*script_call)
    dtm_to_mesh.main(cmd_args)
    tri_meshes = glob.glob(os.path.join(tri_meshes_dir, "*.obj"))

    # Generate the occlusion mesh
    # This mesh is used to compute occlusions and contains all the buildings and roads of the AOI
    # It is generated by merging all the meshes reconstructed at the previous steps
    cmd_args = [tri_meshes_dir, occlusion_mesh]
    merge_raw_obj_meshes.main(cmd_args)

    # -------- Run Texture Mapping --------
    # Images fusion method
    fusion_method = "test"
    logging.info("---- Running texture_mapping ----")
    building_id = 0

    # The following loop iterates over the different meshes that need to be textured.
    # A sub-working-directory is created for each mesh and is used to save all the files
    # generated by run_texture_mapping.
    #
    # meshes is a list of tuples as follows: [(mesh_1_filename, mesh_1_name),
    #                                         (mesh_2_filename, mesh_2_name), ...]
    #       mesh_X_filename: is the complete filename to the mesh X
    #       mesh_X_name: is just the name that we want for the output textured mesh that
    #                    is generated.
    #                    This name is also used for the sub-working-directory of the mesh
    meshes = map(lambda x: (x, os.path.splitext(os.path.basename(x))[0]), tri_meshes)

    for mesh, mesh_name in meshes:
        # create a sub-working-directory per mesh
        current_output_dir = os.path.join(output_dir, mesh_name)
        if not os.path.isdir(current_output_dir):
            os.mkdir(current_output_dir)

        # run_texture_mapping does not like a dir that starts with ./ so remove that
        call_args = [mesh, current_output_dir.replace("./", ""), str(dsmUTMZone),
                     "--output-name", "building_" + mesh_name,
                     "--offset_x", str(offset[0]),
                     "--offset_y", str(offset[1]),
                     "--offset_z", str(offset[2]),
                     "--fusion-method", fusion_method,
                     "--shadows", "no",
                     "--images"] + crops

        # adjust the call arguments for the first mesh
        if building_id == 0:
            # we output the depthmaps using the specified occlusion mesh
            call_args += ["--output-depthmap", os.path.join(current_output_dir, "depthmaps.txt"),
                          "--occlusions", occlusion_mesh]
            initial_output_dir = current_output_dir
        else:
            # for the next meshes, we re-use the generated depthmaps
            call_args += ["--occlusions", os.path.join(initial_output_dir, "depthmaps.txt")]

        if mesh_name == "ground":
            # we use a planar parameterization for the ground to avoid breaking triangles
            call_args += ["--use-planar-parameterization"]
        subprocess_args = ["run_texture_mapping"] + call_args
        print(*subprocess_args)
        subprocess.call(subprocess_args)
        print("\n\n")
        building_id += 1

    logging.info("Copy results to output directory")
    for root, dirs, files in os.walk(output_dir):
        if root == output_dir:
            continue
        for name in files:
            if fnmatch.fnmatch(name, "building_*.*"):
                output_file = os.path.join(output_dir, name)
                try:
                    os.remove(output_file)
                except OSError:
                    pass
                input_file = os.path.join(root, name)
                print("copy({}, {})".format(input_file, output_file))
                shutil.copy(input_file, output_file)

    logging.info("Texture Mapping done")


def main(args):
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("dsm", help="Digital surface model (DSM) image file name")
    parser.add_argument("dtm", help="Digital terrain model (DTM) image file name")
    parser.add_argument("output_dir", help="Output directory for cropped pansharpened images")
    parser.add_argument("occlusion_mesh", help="Occlusion mesh name")
    parser.add_argument("--crops", help="List of croped and pansharpened MSI file names",
                        nargs="+", required=True)
    parser.add_argument("--buildings", help="Source OBJ files representing buildings or roads",
                        nargs="+", required=True)
    args = parser.parse_args(args)

    # Create the output directory if it doesn't already exist
    try:
        os.mkdir(args.output_dir)
    except FileExistsError as e:
        pass

    texture_mapping(args.dsm, args.dtm, args.crops, args.output_dir, args.buildings,
                    args.occlusion_mesh)


if __name__ == '__main__':
    main(sys.argv[1:])
