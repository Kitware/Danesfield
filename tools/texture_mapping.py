#!/usr/bin/env python

"""
Creates the texture mapped OBJ, MTL and texture PNG.
This is part of the pipeline to process an AOI from start to finish
"""

import argparse
from danesfield import gdal_utils
import dtm_to_mesh
import fnmatch
import glob
import logging
import merge_raw_obj_meshes
import os
import osr
import shutil
import subprocess
import sys
import triangulate_mesh


def texture_mapping(dsm_file, dtm_file, crops, output_dir, orig_meshes, occlusion_mesh):
    dsm = gdal_utils.gdal_open(dsm_file)
    dsmProjection = dsm.GetProjection()
    dsmSrs = osr.SpatialReference(wkt=dsmProjection)
    dsmUTMZone = dsmSrs.GetUTMZone()
    print("UTM Zone: {}".format(dsmUTMZone))

    # -------- Prepare meshes --------

    # Turn mesh into triangular faces
    tri_meshes_dir = os.path.join(output_dir, "tri")
    if not os.path.isdir(tri_meshes_dir):
        os.mkdir(tri_meshes_dir)
    # mesh offset
    offset = [0.0, 0.0, 0.0]
    gdal_utils.read_offset(orig_meshes[0], offset)
    print("Offset: {}".format(offset))
    for mesh in orig_meshes:
        cmd_args = [mesh, tri_meshes_dir]
        triangulate_mesh.main(cmd_args)

    # Generate the mesh of the ground
    logging.info("---- Generate ground mesh from DTM ----")
    ground_mesh = os.path.join(tri_meshes_dir, "ground.obj")
    cmd_args = [dtm_file, ground_mesh, "--offset"] + list(map(str, offset)) + ["--downsample", "40"]
    script_call = ["dtm_to_mesh.py"] + cmd_args
    print(*script_call)
    dtm_to_mesh.main(cmd_args)

    # Generate the occlusion mesh
    # This mesh is used to compute occlusions and contains all the buildings and roads of the AOI
    # It is generated by merging all the meshes reconstructed at the previous steps
    cmd_args = [tri_meshes_dir, occlusion_mesh]
    merge_raw_obj_meshes.main(cmd_args)

    # -------- Run Texture Mapping --------
    # Images fusion method
    fusion_method = "test"
    logging.info("---- Running texture_mapping ----")
    building_id = 0

    # The following loop iterates over the different meshes that need to be textured.
    # A sub-working-directory is created for each mesh and is used to save all the files
    # generated by run_texture_mapping.
    #
    # meshes is a list of tuples as follows: [(mesh_1_filename, mesh_1_name),
    #                                         (mesh_2_filename, mesh_2_name), ...]
    #       mesh_X_filename: is the complete filename to the mesh X
    #       mesh_X_name: is just the name that we want for the output textured mesh that
    #                    is generated.
    #                    This name is also used for the sub-working-directory of the mesh
    tri_meshes = glob.glob(os.path.join(tri_meshes_dir, "*.obj"))
    meshes = map(lambda x: (x, os.path.splitext(os.path.basename(x))[0]), tri_meshes)

    for mesh, mesh_name in meshes:
        # create a sub-working-directory per mesh
        current_output_dir = os.path.join(output_dir, mesh_name)
        if not os.path.isdir(current_output_dir):
            os.mkdir(current_output_dir)

        # run_texture_mapping does not like a dir that starts with ./ so remove that
        call_args = [mesh, current_output_dir.replace("./", ""), str(dsmUTMZone),
                     "--output-name", "building_" + mesh_name,
                     "--offset_x", str(offset[0]),
                     "--offset_y", str(offset[1]),
                     "--offset_z", str(offset[2]),
                     "--fusion-method", fusion_method,
                     "--shadows", "no",
                     "--images"] + crops

        # adjust the call arguments for the first mesh
        if building_id == 0:
            # we output the depthmaps using the specified occlusion mesh
            call_args += ["--output-depthmap", os.path.join(current_output_dir, "depthmaps.txt"),
                          "--occlusions", occlusion_mesh]
            initial_output_dir = current_output_dir
        else:
            # for the next meshes, we re-use the generated depthmaps
            call_args += ["--occlusions", os.path.join(initial_output_dir, "depthmaps.txt")]

        subprocess_args = ["run_texture_mapping"] + call_args
        print(*subprocess_args)
        subprocess.call(subprocess_args)
        print("\n\n")
        building_id += 1

    logging.info("Copy results to output directory")
    for root, dirs, files in os.walk(output_dir):
        if root == output_dir:
            continue
        for name in files:
            if fnmatch.fnmatch(name, "building_*.*"):
                output_file = os.path.join(output_dir, name)
                try:
                    os.remove(output_file)
                except OSError:
                    pass
                input_file = os.path.join(root, name)
                print("copy({}, {})".format(input_file, output_file))
                shutil.copy(input_file, output_file)

    logging.info("Texture Mapping done")


def main(args):
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("dsm", help="Digital surface model (DSM) image file name")
    parser.add_argument("dtm", help="Digital terrain model (DTM) image file name")
    parser.add_argument("output_dir", help="Output directory for cropped pansharpened images")
    parser.add_argument("occlusion_mesh", help="Occlusion mesh name")
    parser.add_argument("--crops", help="List of croped and pansharpened MSI file names",
                        nargs="+", required=True)
    parser.add_argument("--buildings", help="Source OBJ files representing buildings or roads",
                        nargs="+", required=True)
    args = parser.parse_args(args)

    # Create the output directory if it doesn't already exist
    try:
        os.mkdir(args.output_dir)
    except FileExistsError as e:
        pass

    texture_mapping(args.dsm, args.dtm, args.crops, args.output_dir, args.buildings,
                    args.occlusion_mesh)


if __name__ == '__main__':
    main(sys.argv[1:])
